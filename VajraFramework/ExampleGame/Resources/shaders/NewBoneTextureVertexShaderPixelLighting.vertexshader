__VARIABLES__
vPosition
vNormal
vNormal_out

uvCoords_in
uvCoords_out

mvpMatrix
modelInverseTransposeMatrix

DLight0Direction
DLight0AmbientColor
DLight0DiffuseColor
DLight0SpecularColor

DLight0Direction_out
DLight0AmbientColor_out
DLight0DiffuseColor_out
DLight0SpecularColor_out

boneIndices
boneWeights
boneTransforms
otherBoneTransforms
interp
__VARIABLES_END__


__SOURCE__
void main()
{
	vec4 posL      = vec4(0.0, 0.0, 0.0, 0.0);
	vec4 posL0     = vec4(0.0, 0.0, 0.0, 0.0);
	vec4 posL1     = vec4(0.0, 0.0, 0.0, 0.0);
	//
	posL0 = posL0 + boneWeights.x * (boneTransforms[int(boneIndices.x)] * vPosition);
	posL0 = posL0 + boneWeights.y * (boneTransforms[int(boneIndices.y)] * vPosition);
	posL0 = posL0 + boneWeights.z * (boneTransforms[int(boneIndices.z)] * vPosition);
	posL0 = posL0 + boneWeights.w * (boneTransforms[int(boneIndices.w)] * vPosition);
	//
	posL1 = posL1 + boneWeights.x * (otherBoneTransforms[int(boneIndices.x)] * vPosition);
	posL1 = posL1 + boneWeights.y * (otherBoneTransforms[int(boneIndices.y)] * vPosition);
	posL1 = posL1 + boneWeights.z * (otherBoneTransforms[int(boneIndices.z)] * vPosition);
	posL1 = posL1 + boneWeights.w * (otherBoneTransforms[int(boneIndices.w)] * vPosition);
	//
	posL.x = posL0.x + (posL1.x - posL0.x) * interp.x;
	posL.y = posL0.y + (posL1.y - posL0.y) * interp.x;
	posL.z = posL0.z + (posL1.z - posL0.z) * interp.x;
	posL.w = posL0.w + (posL1.w - posL0.w) * interp.x;

	gl_Position = mvpMatrix * posL;
	uvCoords_out = uvCoords_in;

	vNormal_out = modelInverseTransposeMatrix * vNormal;

	DLight0Direction_out = DLight0Direction;
	DLight0AmbientColor_out = DLight0AmbientColor;
	DLight0DiffuseColor_out = DLight0DiffuseColor;
	DLight0SpecularColor_out = DLight0SpecularColor;
}
__SOURCE_END__

