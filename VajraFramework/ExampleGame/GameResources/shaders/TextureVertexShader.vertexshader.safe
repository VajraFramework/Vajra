__VERBATIM__
#version 120
__VERBATIM_END__

__VARIABLES__
vPosition
vNormal

vTangent
vBitangent
EyeDirection_cameraspace
LightDirection_cameraspace
LightDirection_tangentspace
vTangent_out
vBitangent_out

uvCoords_in
uvCoords_out

modelMatrix
viewMatrix
projectionMatrix


#ifdef PER_PIXEL_LIGHTING
vNormal_out
#else
lightIntensity
#endif

modelInverseTransposeMatrix

DLight0Direction
DLight0AmbientColor
DLight0DiffuseColor
DLight0SpecularColor

#ifdef PER_PIXEL_LIGHTING
DLight0Direction_out
DLight0AmbientColor_out
DLight0DiffuseColor_out
DLight0SpecularColor_out
#endif

#ifdef BAKED_AMBIENT_LIGHTING
modelCoordsForBakedAmbientLookup_out
#endif

#ifdef ADDITIONAL_LIGHTS
AdditionalLight0Direction
AdditionalLight0Direction_tangentspace
AdditionalLight1Direction
AdditionalLight1Direction_tangentspace
AdditionalLight2Direction
AdditionalLight2Direction_tangentspace
#endif

#ifdef SHADOWMAPS_REALTIME
depthBiasMVPMatrix
ShadowCoord
#endif

__VARIABLES_END__


__SOURCE__

#ifdef SKEW_GEOMETRY
vec4 zSkew = vec4(0.0, 0.0, -.5, 0.0);
vec4 ySkew = vec4(0.0, -0.5, 0.0, 0.0);
#else
vec4 zSkew = vec4(0.0, 0.0, 0.0, 0.0);
vec4 ySkew = vec4(0.0, 0.0, 0.0, 0.0);
#endif

void main()
{
	gl_Position = modelMatrix * vPosition;

#ifdef BAKED_AMBIENT_LIGHTING
	modelCoordsForBakedAmbientLookup_out.x = gl_Position.x;
	modelCoordsForBakedAmbientLookup_out.y = gl_Position.y;
	modelCoordsForBakedAmbientLookup_out.z = gl_Position.z;
#endif

	float yAmt = gl_Position.y;
	vec4 skewed_position = (gl_Position + (zSkew * yAmt) + (ySkew * yAmt));
	gl_Position = projectionMatrix * viewMatrix * skewed_position;
#ifdef SHADOWMAPS_REALTIME
	ShadowCoord = depthBiasMVPMatrix * skewed_position;
#endif

	// Normal mapping stuff ------------------------------------------------------------ 

	vec4 vertexPosition_cameraspace = viewMatrix * modelMatrix * vPosition;
	EyeDirection_cameraspace = vec4(0,0,0,0) - vertexPosition_cameraspace;

	// Vector that goes from the vertex to the light, in camera space. M is ommited because it's identity.
	// TODO [Hack] Hard coded LightPosition_worldspace
	// vec4 LightPosition_worldspace = vec4(10.0, 10.0, 10.0, 1.0);
	// vec4 LightPosition_cameraspace = viewMatrix * DLight0Direction;
	// LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;
	LightDirection_cameraspace = viewMatrix * DLight0Direction + EyeDirection_cameraspace;

	AdditionalLight0Direction_tangentspace = AdditionalLight0Direction; // viewMatrix * AdditionalLight0Direction + EyeDirection_cameraspace;
	AdditionalLight1Direction_tangentspace =  AdditionalLight1Direction; //viewMatrix * AdditionalLight1Direction + EyeDirection_cameraspace;
	AdditionalLight2Direction_tangentspace =  AdditionalLight2Direction; //viewMatrix * AdditionalLight2Direction + EyeDirection_cameraspace;


	// model to camera = ModelView
	mat4 model_view_matrix = viewMatrix * modelMatrix;
	vec4 vTangent_cameraspace = model_view_matrix * vTangent;
	vec4 vBitangent_cameraspace = model_view_matrix * vBitangent;
	vec4 vNormal_cameraspace = model_view_matrix * vNormal;

	mat3 TBN_inv = transpose(mat3(
		vTangent_cameraspace,
		vBitangent_cameraspace,
		vNormal_cameraspace
	));

	mat4 TBN4 = transpose(mat4(
		vTangent_cameraspace,
		vBitangent_cameraspace,
		vNormal_cameraspace,
		vec4(0.0, 0.0, 0.0, 1.0)
	));

	LightDirection_tangentspace = TBN_inv * vec3(LightDirection_cameraspace);

	// AdditionalLight0Direction_tangentspace = TBN4 * AdditionalLight0Direction_tangentspace;
	// AdditionalLight1Direction_tangentspace = TBN4 * AdditionalLight1Direction_tangentspace;
	// AdditionalLight2Direction_tangentspace = TBN4 * AdditionalLight2Direction_tangentspace;

	// Debug:
	vTangent_out = vTangent;
	vBitangent_out = vBitangent;

	// Normal mapping stuff ------------------------------------------------------------ 


	uvCoords_out = uvCoords_in;


#ifdef PER_PIXEL_LIGHTING
	vNormal_out = modelInverseTransposeMatrix * vNormal;

	DLight0Direction_out = DLight0Direction;
	DLight0AmbientColor_out = DLight0AmbientColor;
	DLight0DiffuseColor_out = DLight0DiffuseColor;
	DLight0SpecularColor_out = DLight0SpecularColor;

#else
	vec4 vNormal_world = modelInverseTransposeMatrix * vNormal;
	float cosTheta = clamp( dot( vNormal_world, DLight0Direction ), 0.0, 1.0 );
	lightIntensity = DLight0DiffuseColor * cosTheta;

	// Fake the ambient lighting:
	lightIntensity = lightIntensity + DLight0AmbientColor;

	// Temp using variables:
	lightIntensity = lightIntensity + DLight0SpecularColor;
#endif


}
__SOURCE_END__

