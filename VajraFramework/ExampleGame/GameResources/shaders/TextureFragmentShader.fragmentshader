__VERBATIM__
#ifplatform iOS | Android
precision mediump float;
#endif
__VERBATIM_END__

__VARIABLES__

uvCoords_out

#ifdef PER_PIXEL_LIGHTING
vNormal_out
DLight0Direction_out
DLight0AmbientColor_out
DLight0DiffuseColor_out
DLight0SpecularColor_out
#else
lightIntensity
#endif

myTextureSampler

#ifdef BAKED_AMBIENT_LIGHTING
bakedAmbientGridTextureSampler
modelCoordsForBakedAmbientLookup_out
bakedLightMapSize
#endif


#ifdef ADDITIONAL_LIGHTS
AdditionalLight0Direction
AdditionalLight0Ambient
AdditionalLight0Diffuse
AdditionalLight1Direction
AdditionalLight1Ambient
AdditionalLight1Diffuse
AdditionalLight2Direction
AdditionalLight2Ambient
AdditionalLight2Diffuse
#endif

#ifdef SHADOWMAPS_REALTIME
depthTextureSampler
ShadowCoord
#endif

__VARIABLES_END__

__SOURCE__

#ifdef BAKED_AMBIENT_LIGHTING
float DOWN_AMBIENT_INTENSITY_FACTOR = 0.05;
float UP_AMBIENT_INTENSITY_FACTOR = 0.2;
#endif

void main()
{
#ifdef PER_PIXEL_LIGHTING
	float cosTheta = clamp( dot( vNormal_out, DLight0Direction_out ), 0.0, 1.0 );
	vec4 lightIntensity = DLight0DiffuseColor_out * cosTheta;
	lightIntensity = lightIntensity + DLight0AmbientColor_out;
	// Temp using variables:
	lightIntensity = lightIntensity + DLight0SpecularColor_out;

#ifdef ADDITIONAL_LIGHTS
	cosTheta = clamp( dot( vNormal_out, AdditionalLight0Direction ), 0.0, 1.0 );
	lightIntensity = lightIntensity + AdditionalLight0Diffuse * cosTheta;
	lightIntensity = lightIntensity + AdditionalLight0Ambient;
	//
	cosTheta = clamp( dot( vNormal_out, AdditionalLight1Direction ), 0.0, 1.0 );
	lightIntensity = lightIntensity + AdditionalLight1Diffuse * cosTheta;
	lightIntensity = lightIntensity + AdditionalLight1Ambient;
	//
	cosTheta = clamp( dot( vNormal_out, AdditionalLight2Direction ), 0.0, 1.0 );
	lightIntensity = lightIntensity + AdditionalLight2Diffuse * cosTheta;
	lightIntensity = lightIntensity + AdditionalLight2Ambient;
#endif
#endif


	vec4 finalColor = vec4(1.0, 0.0, 0.0, 1.0);;

#ifdef BAKED_AMBIENT_LIGHTING
	vec4 color_temp = vec4(texture2D(myTextureSampler, uvCoords_out).rgba) * lightIntensity;

	vec2 uv_into_bakedmap = modelCoordsForBakedAmbientLookup_out.xz;
	// Adjust uv into bakedmap according to the size of exported map:
	uv_into_bakedmap.x = (uv_into_bakedmap.x + 0.5) / bakedLightMapSize;
	uv_into_bakedmap.y = -1.0 * (uv_into_bakedmap.y - 0.5) / bakedLightMapSize;
	vec4 baked_ambient_value = texture2D(bakedAmbientGridTextureSampler, uv_into_bakedmap);
	float down_ambient_intensity_at_point = baked_ambient_value.r;
	float up_ambient_intensity_at_point = baked_ambient_value.g;
	float height_cutoof_at_pixel = baked_ambient_value.b * 10.0;

	// TODO [Hack] Not applying ambient occlusion to heights above 2.0, change this to be read from the blue channel of the baked map instead:
	if (modelCoordsForBakedAmbientLookup_out.y > height_cutoof_at_pixel) {
		down_ambient_intensity_at_point = 0.0;
	}
	finalColor = color_temp - down_ambient_intensity_at_point * DOWN_AMBIENT_INTENSITY_FACTOR + up_ambient_intensity_at_point * UP_AMBIENT_INTENSITY_FACTOR;
#else
	finalColor = vec4(texture2D(myTextureSampler, uvCoords_out).rgba) * lightIntensity;
#endif
	
#ifdef SHADOWMAPS_REALTIME
	// float visibility = 0.001;
	float visibility = texture2D( depthTextureSampler, ShadowCoord.xy).r - ShadowCoord.z;
	visibility = clamp (visibility * 50.0 + 1.0, 0.0, 1.0);

	// vec2 uv_into_pixelspace = vec2(gl_FragCoord.x / 1024.0, gl_FragCoord.y / 768.0);
	// vec4 depthMap_value = vec4(texture2D(depthTextureSampler, uv_into_pixelspace).rgba);

	// finalColor = finalColor * 0.001 + vec4(depthMap_value.x, depthMap_value.x, depthMap_value.x, 1.0);

	// finalColor = finalColor * visibility * 0.001 + ShadowCoord;
	finalColor = finalColor * (visibility + 0.5); // + finalColor;
	// float number = ShadowCoord.y / ShadowCoord.w;
	// finalColor = finalColor * number; // + vec4(number, number, number, 1.0);

	// finalColor = finalColor * 0.001 + texture2D(depthTextureSampler, vec2(gl_FragCoord.x / 1024.0, gl_FragCoord.y / 768.0));

	// finalColor = finalColor * 0.001 + vec4(ShadowCoord.z, ShadowCoord.z, ShadowCoord.z, 1.0);

	finalColor.a = 1.0;

#endif

	gl_FragColor = finalColor;
}

__SOURCE_END__

